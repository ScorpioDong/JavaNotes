# Day 13

## 1. 泛型

### 1.1 什么是泛型，为什么引入泛型

```
	目前项目，功能是可以考虑之后的复用的。当前代码值支持Student类，如果需要更换数据类型，智能重新完成对应数据类型的功能键代码。
	
	这里不单单是对于功能模块的要求而封装。统统是需要对数据类型进行统一的约束。根据用户的要求队形数据类型。
	
Java中的泛型就是来解决对应的问题
	格式
		<自定义泛型无意义大写字母占位符>
		<T> <E> <K> <V> 
		T Type
		E Element
		K Key
		V Value
		
	泛型可以在方法中使用
	泛型可以在类中使用
	泛型可以在接口中使用
```

### 1.2 泛型在方法中使用

```
格式
	public static <T> 返回值类型[自定义类型] 方法名(自定义类型 变量)
	
使用注意事项：
	1. 自定义泛型声明在返回值之前，已保证方法的参数和返回值都可以使用对应的泛型
	2. 方法声明的泛型，在方法的参数中必须有一个参数是对应声明的自定义泛型。当前参数是用于约束方法内所有使用到泛型的位置对应的具体数据类型是什么。
```

### 1.3 泛型在类内使用

```
格式
	class 类名<自定义类名无意义大写字母占位符> {
		成员变量和成员方法都可以使用自定义泛型
		不建议成员变量使用
	}
	
使用注意事项:
	1. 类声明自定义泛型，需要通过创建对象的方式来约束
		TypeA<String> typeA = new TypeA<String>(); Eclipse标准写法
		TypeA<String> typeA = new TypeA<>(); IDEA写法
	2. 类声明泛型约束之后，在类内的所有成员方法中使用的泛型都是类约束的泛型具体数据类型
	3. 如果没有约束类声明泛型，所有使用到泛型的位置都是Object，【不推荐】
	4. 类声明的自定义泛型不能用于类内的静态方法【没有对象】
```

### 1.4 泛型在接口中使用

```
格式
	interface 接口名<自定义泛型无意义占位符> {
		// 不能用于成员变量，数据类型不明确，无法进行初始化过程
		// 只能用于成员方法
	}
	
使用注意事项：
	1. 接口声明的泛型，有且只能用于类内的成员方法。
		问题： default修饰的方法是否可以使用接口声明的自定义泛型
	2. 遵从带有自定义泛型的接口的类，一种可以遵从过程中明确告知泛型具体类型，一种是在创建类对象是明确泛型具体数据类型。
	3. class TypeA<T> implements A<String> 
		正确
			接口的泛型明确接口中的方法，使用泛型对应的具体数据类型
			类声明的泛型用于自定义约束自己类内的方法
	4. class TypeA<E> implements A<T>
		错误
			接口中的泛型没有明确数据类型，也无法通过类创建对象的过程中明确
			泛型对应的具体数据类型，无法编译
```

## 2. 匿名内部类

```
使用接口和接口实现类完成算法普适性的优化，

问题：
	大量内容相似的实现类，对于代码运行而言，类文件太多。。。

目标
	1. 使用方法来完成比较方式，从而满足复用问题
	2. 类名只是因为Java中所有的代码都在类内，所以需要这样的条件	
```

```
Anonymous Inner Type
没有名字的类

匿名内部类
匿名内部类的匿名对象直接调用方法
匿名内部类的匿名对象直接当做方法参数
```

## 3. 集合

### 3.1 为什么使用集合

```
使用数组
	1. 数组能够使用的方法非常少，功能方法需要程序员自己完成
	2. 数据类型单一化，不支持多种情况
	3. 数组容量不可以更改
	
集合
	1. 方法多种多样，基本功能完善
	2. 数据类型支持多样化，但又不失数据类型一致要求
	3. 容量可以变，并且不用开发者操心
```

### 3.2 集合架构

```
Java中集合的【总接口】Collection<E> 。Java中的所有和集合有关的内容，都是Collection<E>接口的子接口或者实现类

interface Collection<E>
--| interface List<E> List接口，有序可重复
----| class ArrayList<E> 
		[重点]可变长数组接口
		源码实现，了解其中的特性，性能...
----| class LinkedList<E>
		[重点]双向链表结构
----| class Vector<E>
		[远古时代] JDK1.0 线程安全的ArrayList
		如果不考虑线程安全问题，推线使用ArrayList
--| interface Set<E> Set接口，无序不可重复
----| class HashSet<E> 底层存储数据的方式采用哈希表方式 
----| class TreeSet<E>  底层存储数据的方式一个平衡二叉树方式
```

### 3.3 `Collection<E>`接口下的常用方法

```
增：
	boolean add(E e);
		存入元素到当前集合对象中，这里要求的数据类型是E类型，也就是泛型
	boolean addAll(Collection<? extends E> c);
		要求存入的集合c中，存储的元素要么是E类型，要么是E类的子类
删：
	void clear();
		清空整个集合
	boolean remove(Object obj);
		删除集合中的指定元素
	boolean removeAll(Collection<?> c)
		删除两个集合的交集
	boolean retainAll(Collection<?> c)
		保留两个集合的交集
查：
	int size();
		返回集合中有效元素个数
	boolean isEnpty();
		判断集合是否为空
	boolean contains(Object obj);
		判断指定元素是否存在
	boolean containsAll(Collection<?> c);
    	判断集合是不是当前集合的子集合
```

